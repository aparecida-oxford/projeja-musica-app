<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Gerador de Slides de Letras - Sequ√™ncia de M√∫sicas</title>
<script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin:0; padding:0; background:#1e1f29; color:#f0f0f0; }
.container { max-width:1200px; margin:0 auto; padding:30px; }
h2 { text-align:center; margin-bottom:20px; color:#5b8cff; }
.section { background:#2b2d42; padding:20px; margin-bottom:20px; border-radius:10px; }
.section h3 { color:#5b8cff; margin-top:0; border-bottom:2px solid #5b8cff; padding-bottom:10px; }
textarea { width:100%; height:120px; padding:12px; border-radius:10px; border:none; resize:vertical; background:#3e4062; color:#f0f0f0; font-size:16px; }
.options { display:grid; grid-template-columns:repeat(auto-fit, minmax(220px,1fr)); gap:20px; margin:20px 0; }
label { display:block; margin-bottom:5px; font-weight:600; }
input[type=color], input[type=number], select { width:100%; padding:8px; border-radius:8px; border:none; background:#3e4062; color:#f0f0f0; }
input[type=file] { width:100%; padding:8px; border-radius:8px; border:2px dashed #5b8cff; background:#3e4062; color:#f0f0f0; }
button { padding:12px 24px; margin-right:10px; margin-bottom:10px; border:none; border-radius:10px; cursor:pointer; background:#5b8cff; color:#fff; font-weight:bold; transition:0.3s; }
button:hover { background:#3a6ee8; }
button.secondary { background:#6c757d; }
button.secondary:hover { background:#545b62; }
button.danger { background:#e85b5b; }
button.danger:hover { background:#d63031; }
#preview { background:#3e4062; padding:15px; margin-top:20px; border-radius:10px; overflow:auto; }
.music-list { margin-top:20px; }
.music-item { padding:15px; margin-bottom:8px; background:#3e4062; border-radius:8px; display:flex; justify-content:space-between; align-items:center; cursor:grab; position:relative; }
.music-item.editing { background:#4a5568; }
.music-title { flex:1; margin-right:10px; word-break:break-word; }
.music-actions { display:flex; gap:10px; }
.remove-btn, .edit-btn { padding:6px 12px; border-radius:6px; font-weight:bold; cursor:pointer; font-size:12px; }
.remove-btn { background:#e85b5b; }
.edit-btn { background:#ffa500; }
.edit-btn { background:#ffa500; }
.edit-form { margin-top:15px; padding:15px; background:#2b2d42; border-radius:8px; }
.edit-form textarea { height:200px; }
.progress { background:#2b2d42; border-radius:10px; margin-top:20px; padding:15px; }
.progress-bar { background:#5b8cff; height:8px; border-radius:4px; width:0%; transition:width 0.3s; }
.log { background:#2b2d42; border-radius:10px; margin-top:20px; padding:15px; max-height:300px; overflow-y:auto; }
.log-item { padding:5px 0; border-bottom:1px solid #333; font-size:14px; }
.log-warning { color:#ffa500; }
.log-error { color:#e85b5b; }
.log-success { color:#5baa47; }
.log-info { color:#17a2b8; }
.hidden { display: none; }
#textMeasure { position: absolute; left: -9999px; top: -9999px; white-space: pre-wrap; }
.import-section { border:2px dashed #5b8cff; padding:20px; text-align:center; }
.import-info { margin-bottom:15px; color:#adb5bd; }
.tabs { display:flex; margin-bottom:20px; border-bottom:2px solid #3e4062; }
.tab { padding:10px 20px; cursor:pointer; background:#3e4062; margin-right:5px; border-radius:8px 8px 0 0; }
.tab.active { background:#5b8cff; }
.tab-content { display:none; }
.tab-content.active { display:block; }
.slide-preview { background:#4a5568; padding:5px; margin:5px 0; border-radius:5px; font-size:12px; border-left:3px solid #5b8cff; }
.slide-preview-text { max-height:75px; overflow:hidden; }
</style>
</head>
<body>
<div class="container">
<h2>Gerador de Slides de Letras - Sequ√™ncia de M√∫sicas</h2>

<div class="tabs">
  <div class="tab active" onclick="switchTab('create')">Criar Novo</div>
  <div class="tab" onclick="switchTab('import')">Importar PPTX</div>
</div>

<div id="createTab" class="tab-content active">
  <div class="section">
    <h3>üéµ Adicionar Nova M√∫sica</h3>
    <textarea id="lyrics" placeholder="Cole a letra da m√∫sica aqui, com estrofes separadas por uma linha em branco..."></textarea>
    <button onclick="addMusic()">Adicionar M√∫sica √† Sequ√™ncia</button>
  </div>
</div>

<div id="importTab" class="tab-content">
  <div class="section">
    <h3>üìÇ Importar Apresenta√ß√£o Existente</h3>
    <div class="import-section">
      <div class="import-info">
        Selecione um arquivo PowerPoint (.pptx) para importar os slides existentes.<br>
        <strong>üîç Detec√ß√£o Autom√°tica:</strong> O sistema tentar√° identificar m√∫sicas separadas.<br>
        <strong>‚úèÔ∏è Edi√ß√£o Manual:</strong> Voc√™ sempre pode editar e separar as m√∫sicas depois.
      </div>
      <input type="file" id="importFile" accept=".pptx" onchange="importPPTX()">
      <div style="margin-top:15px; padding:10px; background:#3e4062; border-radius:5px; font-size:12px; color:#adb5bd;">
        <strong>üí° Para melhor separa√ß√£o autom√°tica:</strong><br>
        ‚Ä¢ Deixe slides vazios entre m√∫sicas diferentes<br>
        ‚Ä¢ Use numera√ß√£o clara: "M√∫sica 1:", "Hino 2 -"<br>
        ‚Ä¢ Use "T√≠tulo:" antes do nome da m√∫sica<br><br>
        <strong>‚ö†Ô∏è N√£o se preocupe:</strong> Mesmo que seja importado como uma m√∫sica s√≥, voc√™ pode editar e separar manualmente depois!
      </div>
    </div>
  </div>
</div>

<div class="section">
  <h3>‚öôÔ∏è Configura√ß√µes de Formata√ß√£o</h3>
  <div class="options">
    <div>
      <label>Cor do texto</label>
      <input type="color" id="textColor" value="#FFFFFF">
    </div>
    <div>
      <label>Cor de fundo do slide</label>
      <input type="color" id="bgColor" value="#000000">
    </div>
    <div>
      <label>Tamanho da fonte inicial</label>
      <input type="number" id="fontSize" value="47" min="12" max="72">
    </div>
    <div>
      <label>Tamanho m√≠nimo da fonte</label>
      <input type="number" id="minFontSize" value="24" min="12" max="48">
    </div>
    <div>
      <label>Tipo da Fonte</label>
      <select id="fontFamily">
        <option value="Arial">Arial</option>
        <option value="Calibri">Calibri</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Georgia">Georgia</option>
        <option value="Verdana">Verdana</option>
      </select>
    </div>
    <div>
      <label>Efeitos</label>
      <select id="fontEffects" multiple>
        <option value="bold">Negrito</option>
        <option value="italic">It√°lico</option>
      </select>
      <small style="display:block; color:#adb5bd; margin-top:5px;">(Segure Ctrl/Cmd para selecionar mais de um)</small>
    </div>
    <div>
      <label>Alinhamento</label>
      <select id="align">
        <option value="center">Centralizado</option>
        <option value="left">Esquerda</option>
        <option value="right">Direita</option>
        <option value="justify">Justificado</option>
      </select>
    </div>
    <div>
      <label>Layout</label>
      <select id="layout">
        <option value="LAYOUT_16x9">16:9</option>
        <option value="LAYOUT_4x3">4:3</option>
      </select>
    </div>
    <div>
      <label>Caixa de texto</label>
      <select id="caseOption">
        <option value="normal">Normal</option>
        <option value="upper">MAI√öSCULAS</option>
        <option value="lower">min√∫sculas</option>
      </select>
    </div>
    <div>
      <label>Quando texto n√£o couber</label>
      <select id="overflowOption">
        <option value="smart">Quebra inteligente + ajustes</option>
        <option value="shrink">Reduzir fonte</option>
        <option value="split">Dividir em slides</option>
        <option value="both">Tentar reduzir, se n√£o couber dividir</option>
      </select>
    </div>
  </div>
</div>

<div class="section">
  <h3>üéµ Sequ√™ncia de M√∫sicas</h3>
  <button onclick="generatePPTX()">üìä Gerar .pptx</button>
  <button class="secondary" onclick="previewSlides()">üëÅÔ∏è Visualizar Slides</button>
  <button class="danger" onclick="clearAll()">üóëÔ∏è Limpar Tudo</button>
  
  <div class="music-list" id="musicList"></div>
</div>

<div class="progress hidden" id="progress">
  <div>Processando slides...</div>
  <div class="progress-bar" id="progressBar"></div>
</div>

<div class="log hidden" id="log">
  <h3>üìã Log de Processamento:</h3>
  <div id="logContent"></div>
</div>

<div id="preview" class="hidden">
  <h3>üëÅÔ∏è Pr√©-visualiza√ß√£o dos Slides:</h3>
  <div id="previewContent"></div>
</div>

<div id="textMeasure"></div>

</div>

<script>
let musicSequence = [];
let editingIndex = -1;

function switchTab(tabName) {
  // Esconder todas as abas
  document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
  document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
  
  // Mostrar aba selecionada
  document.getElementById(tabName + 'Tab').classList.add('active');
  event.target.classList.add('active');
}

function addMusic() {
  let text = document.getElementById("lyrics").value.trim();
  if (!text) return alert("Insira a letra da m√∫sica primeiro.");

  musicSequence.push(text);
  document.getElementById("lyrics").value = "";
  renderMusicList();
  addLog(`M√∫sica ${musicSequence.length} adicionada com sucesso`, 'success');
}

function editMusic(index) {
  if (editingIndex !== -1) {
    // Cancelar edi√ß√£o anterior
    cancelEdit();
  }
  
  editingIndex = index;
  renderMusicList();
}

function saveEdit(index) {
  const textarea = document.getElementById(`edit-textarea-${index}`);
  if (textarea) {
    musicSequence[index] = textarea.value.trim();
    editingIndex = -1;
    renderMusicList();
    addLog(`M√∫sica ${index + 1} editada com sucesso`, 'success');
  }
}

function cancelEdit() {
  editingIndex = -1;
  renderMusicList();
}

function removeMusic(index) {
  if (confirm(`Tem certeza que deseja remover a m√∫sica ${index + 1}?`)) {
    musicSequence.splice(index, 1);
    if (editingIndex === index) editingIndex = -1;
    if (editingIndex > index) editingIndex--;
    renderMusicList();
    addLog(`M√∫sica ${index + 1} removida`, 'warning');
  }
}

function moveMusic(from, to) {
  if (from === to) return;
  const temp = musicSequence[from];
  musicSequence.splice(from, 1);
  musicSequence.splice(to, 0, temp);
  
  // Ajustar √≠ndice de edi√ß√£o se necess√°rio
  if (editingIndex === from) editingIndex = to;
  else if (editingIndex > from && editingIndex <= to) editingIndex--;
  else if (editingIndex < from && editingIndex >= to) editingIndex++;
  
  renderMusicList();
}

function renderMusicList() {
  const list = document.getElementById("musicList");
  list.innerHTML = "";
  
  if (musicSequence.length === 0) {
    list.innerHTML = '<div style="text-align:center; color:#6c757d; padding:20px;">Nenhuma m√∫sica adicionada ainda</div>';
    return;
  }
  
  musicSequence.forEach((music, i) => {
    const div = document.createElement("div");
    div.className = `music-item ${editingIndex === i ? 'editing' : ''}`;
    div.draggable = editingIndex !== i;
    div.dataset.index = i;

    if (editingIndex !== i) {
      div.addEventListener("dragstart", (e) => { e.dataTransfer.setData("text/plain", i); });
      div.addEventListener("dragover", (e) => { e.preventDefault(); });
      div.addEventListener("drop", (e) => {
        e.preventDefault();
        const from = parseInt(e.dataTransfer.getData("text/plain"));
        const to = parseInt(div.dataset.index);
        moveMusic(from, to);
      });
    }

    const titleDiv = document.createElement("div");
    titleDiv.className = "music-title";
    
    if (editingIndex === i) {
      // Modo de edi√ß√£o
      titleDiv.innerHTML = `
        <strong>Editando M√∫sica ${i + 1}:</strong>
        <div class="edit-form">
          <textarea id="edit-textarea-${i}" placeholder="Cole a letra da m√∫sica aqui...">${music}</textarea>
          <div style="margin-top:10px;">
            <button onclick="saveEdit(${i})">üíæ Salvar</button>
            <button class="secondary" onclick="cancelEdit()">‚ùå Cancelar</button>
          </div>
        </div>
      `;
    } else {
      // Modo de visualiza√ß√£o
      const preview = music.length > 100 ? music.substring(0, 100) + "..." : music;
      const firstLine = music.split('\n')[0];
      titleDiv.innerHTML = `
        <strong>M√∫sica ${i + 1}:</strong><br>
        <em>${firstLine}</em><br>
        <small style="color:#adb5bd;">${music.split('\n\n').length} estrofe(s)</small>
      `;
    }

    const actionsDiv = document.createElement("div");
    actionsDiv.className = "music-actions";
    
    if (editingIndex !== i) {
      actionsDiv.innerHTML = `
        <div class="edit-btn" onclick="editMusic(${i})">‚úèÔ∏è Editar</div>
        <div class="remove-btn" onclick="removeMusic(${i})">üóëÔ∏è Remover</div>
      `;
    }

    div.appendChild(titleDiv);
    if (editingIndex !== i) {
      div.appendChild(actionsDiv);
    }
    list.appendChild(div);
  });
}

function clearAll() {
  if (confirm("Tem certeza que deseja limpar toda a sequ√™ncia de m√∫sicas?")) {
    musicSequence = [];
    editingIndex = -1;
    renderMusicList();
    document.getElementById("preview").classList.add("hidden");
    addLog("Sequ√™ncia de m√∫sicas limpa", 'warning');
  }
}

// Fun√ß√£o para importar PPTX
async function importPPTX() {
  const fileInput = document.getElementById('importFile');
  const file = fileInput.files[0];
  
  if (!file) return;
  
  addLog('Iniciando importa√ß√£o do arquivo PPTX...', 'info');
  
  try {
    const arrayBuffer = await file.arrayBuffer();
    const zip = await JSZip.loadAsync(arrayBuffer);
    
    // Extrair slides do arquivo
    const slides = [];
    let slideIndex = 1;
    
    while (true) {
      const slidePath = `ppt/slides/slide${slideIndex}.xml`;
      const slideFile = zip.file(slidePath);
      
      if (!slideFile) break;
      
      const slideXml = await slideFile.async('text');
      const slideText = extractTextFromSlideXml(slideXml);
      
      // Adiciona o slide mesmo se estiver vazio (para detectar separadores)
      slides.push(slideText);
      
      slideIndex++;
    }
    
    if (slides.length === 0) {
      addLog('Nenhum slide encontrado no arquivo', 'warning');
      return;
    }
    
    addLog(`${slides.length} slides extra√≠dos, tentando identificar m√∫sicas...`, 'info');
    
    // Agrupar slides em m√∫sicas com abordagem conservadora
    const importedMusics = groupSlidesIntoMusics(slides);
    
    if (importedMusics.length === 0) {
      addLog('Nenhuma m√∫sica p√¥de ser identificada', 'warning');
      return;
    }
    
    // Limpar m√∫sicas vazias
    const validMusics = importedMusics.filter(music => music.trim().length > 0);
    
    if (validMusics.length === 0) {
      addLog('Nenhum conte√∫do v√°lido encontrado', 'warning');
      return;
    }
    
    // Mostrar resultado da detec√ß√£o autom√°tica
    const detectionMessage = validMusics.length === 1 
      ? `O sistema detectou TODO o conte√∫do como UMA √öNICA m√∫sica.\n\nIsso pode estar correto, ou voc√™ pode precisar separar manualmente.\n\nDeseja prosseguir?`
      : `O sistema detectou ${validMusics.length} m√∫sicas automaticamente.\n\nVerifique se a separa√ß√£o est√° correta ap√≥s a importa√ß√£o.\n\nDeseja prosseguir?`;
    
    if (!confirm(detectionMessage)) {
      addLog('Importa√ß√£o cancelada pelo usu√°rio', 'info');
      return;
    }
    
    // Perguntar se deseja substituir ou adicionar
    const shouldReplace = musicSequence.length > 0 ? confirm(
      `Voc√™ j√° possui ${musicSequence.length} m√∫sica(s) na sequ√™ncia.\n\n` +
      `Clique OK para SUBSTITUIR toda a sequ√™ncia atual,\n` +
      `ou Cancelar para ADICIONAR as novas m√∫sicas ao final.`
    ) : true;
    
    if (shouldReplace) {
      musicSequence = [];
      editingIndex = -1;
      addLog('Sequ√™ncia atual limpa', 'info');
    }
    
    // Adicionar m√∫sicas importadas
    validMusics.forEach((music, index) => {
      musicSequence.push(music.trim());
      const preview = music.trim().split('\n')[0].substring(0, 50);
      addLog(`M√∫sica ${musicSequence.length} importada: "${preview}${preview.length >= 50 ? '...' : ''}"`, 'success');
    });
    
    renderMusicList();
    switchTab('create');
    
    addLog(`‚úÖ Importa√ß√£o conclu√≠da! ${validMusics.length} m√∫sica(s) ${shouldReplace ? 'substitu√≠das' : 'adicionadas'}`, 'success');
    
    // Alertar sobre edi√ß√£o manual se necess√°rio
    if (validMusics.length === 1 && slides.length > 10) {
      addLog('üí° DICA: Se o conte√∫do cont√©m v√°rias m√∫sicas, use o bot√£o "Editar" para separ√°-las manualmente', 'info');
      setTimeout(() => {
        alert('DICA: Como foi importada apenas 1 m√∫sica de v√°rios slides,\nvoc√™ pode usar o bot√£o "‚úèÔ∏è Editar" para separar as m√∫sicas manualmente.\n\nBasta dividir o texto usando linhas em branco duplas entre cada m√∫sica.');
      }, 1000);
    }
    
  } catch (error) {
    addLog('‚ùå Erro ao importar arquivo: ' + error.message, 'error');
    console.error('Erro na importa√ß√£o:', error);
  }
  
  // Limpar input
  fileInput.value = '';
}

function extractTextFromSlideXml(xml) {
  // Extrair texto dos elementos <a:t> (texto) do XML do slide
  const textMatches = xml.match(/<a:t[^>]*>([^<]*)<\/a:t>/g);
  if (!textMatches) return '';
  
  const texts = textMatches.map(match => {
    const textContent = match.replace(/<a:t[^>]*>/, '').replace(/<\/a:t>/, '');
    return decodeXmlEntities(textContent);
  });
  
  return texts.join('\n').trim();
}

function decodeXmlEntities(text) {
  const entities = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };
  
  return text.replace(/&[a-zA-Z0-9#]+;/g, (entity) => entities[entity] || entity);
}

function groupSlidesIntoMusics(slides) {
  // Primeira tentativa: apenas slides vazios como separadores
  const musicsByEmpty = groupByEmptySlides(slides);
  
  // Se conseguiu uma separa√ß√£o razo√°vel, use ela
  if (musicsByEmpty.length > 1 && musicsByEmpty.length <= Math.ceil(slides.length / 3)) {
    return musicsByEmpty;
  }
  
  // Segunda tentativa: padr√µes muito √≥bvios apenas
  const musicsByPatterns = groupByObviousPatterns(slides);
  
  // Se ainda n√£o funcionou, deixa tudo como uma m√∫sica para revis√£o manual
  if (musicsByPatterns.length <= 1) {
    return [slides.filter(slide => slide.trim()).join('\n\n')];
  }
  
  return musicsByPatterns;
}

function groupByEmptySlides(slides) {
  const musics = [];
  let currentMusic = [];
  
  for (let slide of slides) {
    if (slide.trim() === '') {
      // Slide vazio - separador entre m√∫sicas
      if (currentMusic.length > 0) {
        musics.push(currentMusic.join('\n\n'));
        currentMusic = [];
      }
    } else {
      currentMusic.push(slide);
    }
  }
  
  // Adicionar √∫ltima m√∫sica se houver
  if (currentMusic.length > 0) {
    musics.push(currentMusic.join('\n\n'));
  }
  
  return musics;
}

function groupByObviousPatterns(slides) {
  const musics = [];
  let currentMusic = [];
  
  for (let i = 0; i < slides.length; i++) {
    const slide = slides[i];
    const slideText = slide.trim();
    
    if (slideText === '') continue;
    
    // Padr√µes MUITO √≥bvios para nova m√∫sica
    const isVeryObviousStart = detectVeryObviousStart(slideText);
    
    if (isVeryObviousStart && currentMusic.length > 0) {
      // Finalizar m√∫sica anterior
      musics.push(currentMusic.join('\n\n'));
      currentMusic = [slideText];
    } else {
      currentMusic.push(slideText);
    }
  }
  
  // Adicionar √∫ltima m√∫sica
  if (currentMusic.length > 0) {
    musics.push(currentMusic.join('\n\n'));
  }
  
  return musics;
}

function detectVeryObviousStart(slideText) {
  const text = slideText.trim();
  
  // Apenas padr√µes MUITO √≥bvios
  const veryObviousPatterns = [
    /^(m√∫sica|song|hino)\s*\d+\s*[-:]/i,  // "M√∫sica 1:", "Hino 2 -"
    /^\d+\s*[-\.]\s*[A-Z√Ä√à√å√í√ô√Å√â√ç√ì√ö√Ç√ä√é√î√õ√É√ï√á]/,       // "1. Nome", "2 - T√≠tulo"
    /^(t√≠tulo|title)\s*:/i,               // "T√≠tulo:", "Title:"
  ];
  
  return veryObviousPatterns.some(pattern => pattern.test(text));
}

function previewSlides() {
  if (musicSequence.length === 0) {
    alert("Adicione pelo menos uma m√∫sica para visualizar os slides.");
    return;
  }
  
  const previewDiv = document.getElementById("preview");
  const previewContent = document.getElementById("previewContent");
  previewContent.innerHTML = "";
  
  const caseOpt = document.getElementById("caseOption").value;
  let slideCount = 0;
  
  musicSequence.forEach((music, musicIndex) => {
    let processedMusic = music;
    if (caseOpt === "upper") processedMusic = processedMusic.toUpperCase();
    if (caseOpt === "lower") processedMusic = processedMusic.toLowerCase();
    
    const blocks = processedMusic.split(/\n\s*\n/).map(b => b.trim().replace(/\n{2,}/g, "\n"));
    
    blocks.forEach((block, blockIndex) => {
      if (block.trim()) {
        slideCount++;
        const slideDiv = document.createElement("div");
        slideDiv.className = "slide-preview";
        slideDiv.innerHTML = `
          <strong>Slide ${slideCount} - M√∫sica ${musicIndex + 1}, Estrofe ${blockIndex + 1}:</strong>
          <div class="slide-preview-text">${block.replace(/\n/g, '<br>')}</div>
        `;
        previewContent.appendChild(slideDiv);
      }
    });
    
    // Slide separador (exceto na √∫ltima m√∫sica)
    if (musicIndex < musicSequence.length - 1) {
      slideCount++;
      const separatorDiv = document.createElement("div");
      separatorDiv.className = "slide-preview";
      separatorDiv.style.borderLeft = "3px solid #6c757d";
      separatorDiv.innerHTML = `<strong>Slide ${slideCount}:</strong> <em>(Slide vazio - separador)</em>`;
      previewContent.appendChild(separatorDiv);
    }
  });
  
  previewDiv.classList.remove("hidden");
  addLog(`Pr√©-visualiza√ß√£o gerada com ${slideCount} slides`, 'info');
}

// Fun√ß√£o para medir texto
function measureText(text, fontSize, fontFamily = 'Arial') {
  const measurer = document.getElementById('textMeasure');
  measurer.style.fontSize = fontSize + 'px';
  measurer.style.fontFamily = fontFamily;
  measurer.style.lineHeight = '1.2';
  measurer.textContent = text;
  
  return {
    width: measurer.offsetWidth,
    height: measurer.offsetHeight
  };
}

// Fun√ß√£o para calcular dimens√µes do slide baseado no layout
function getSlideConstraints(layout) {
  const layouts = {
    'LAYOUT_16x9': { width: 960, height: 540 },
    'LAYOUT_4x3': { width: 720, height: 540 }
  };
  
  const base = layouts[layout] || layouts['LAYOUT_16x9'];
  return {
    width: base.width * 0.8,
    height: base.height * 0.8
  };
}

// NOVA FUN√á√ÉO: Quebra de linha inteligente com valida√ß√£o de altura
function applySmartLineBreaks(text, maxWidth, maxHeight, fontSize, fontFamily = 'Arial') {
  const lines = text.split('\n');
  const optimizedLines = [];
  
  for (let line of lines) {
    const words = line.trim().split(' ');
    if (words.length <= 1) {
      optimizedLines.push(line);
      continue;
    }
    
    // Verificar se a linha atual cabe na largura
    const lineDimensions = measureText(line, fontSize, fontFamily);
    if (lineDimensions.width <= maxWidth) {
      optimizedLines.push(line);
      continue;
    }
    
    // Quebrar a linha em partes menores
    let currentLine = '';
    for (let word of words) {
      const testLine = currentLine ? currentLine + ' ' + word : word;
      const testDimensions = measureText(testLine, fontSize, fontFamily);
      
      if (testDimensions.width <= maxWidth) {
        currentLine = testLine;
      } else {
        if (currentLine) {
          optimizedLines.push(currentLine);
          currentLine = word;
        } else {
          // Palavra muito longa, for√ßar quebra
          optimizedLines.push(word);
          currentLine = '';
        }
      }
    }
    
    if (currentLine) {
      optimizedLines.push(currentLine);
    }
  }
  
  const finalText = optimizedLines.join('\n');
  
  // VALIDA√á√ÉO CR√çTICA: Verificar se o texto final cabe na altura
  const finalDimensions = measureText(finalText, fontSize, fontFamily);
  if (finalDimensions.height > maxHeight) {
    addLog(`‚ö†Ô∏è Texto com quebras ainda excede altura (${finalDimensions.height}px > ${maxHeight}px)`, 'warning');
    return null; // Indica que precisa de divis√£o em slides
  }
  
  return finalText;
}

// NOVA FUN√á√ÉO: Processamento inteligente de texto com valida√ß√£o rigorosa de altura
function processTextForSlide(text, constraints, initialFontSize, minFontSize, overflowOption, fontFamily) {
  addLog(`Processando texto: "${text.substring(0, 30)}${text.length > 30 ? '...' : ''}"`, 'info');
  
  // ETAPA 1: Tentar quebra de linha inteligente com fonte original
  let processedText = applySmartLineBreaks(text, constraints.width, constraints.height, initialFontSize, fontFamily);
  
  if (processedText !== null) {
    let dimensions = measureText(processedText, initialFontSize, fontFamily);
    if (dimensions.width <= constraints.width && dimensions.height <= constraints.height) {
      addLog('‚úì Texto ajustado com quebras de linha inteligentes', 'success');
      return [{ text: processedText, fontSize: initialFontSize }];
    }
  }
  
  // ETAPA 2: Se quebras de linha n√£o funcionaram, tentar outras estrat√©gias
  addLog('Quebras de linha n√£o foram suficientes, aplicando outras estrat√©gias...', 'warning');
  
  if (overflowOption === 'smart' || overflowOption === 'shrink' || overflowOption === 'both') {
    // Tentar reduzir fonte com quebras de linha
    if (processedText !== null) {
      const optimalSize = findOptimalFontSize(processedText, constraints.width, constraints.height, initialFontSize, minFontSize, fontFamily);
      
      if (optimalSize >= minFontSize) {
        const newDimensions = measureText(processedText, optimalSize, fontFamily);
        if (newDimensions.width <= constraints.width && newDimensions.height <= constraints.height) {
          addLog(`‚úì Fonte reduzida para ${optimalSize}px com quebras otimizadas`, 'success');
          return [{ text: processedText, fontSize: optimalSize }];
        }
      }
    }
    
    // Tentar reduzir fonte com texto original
    const originalOptimalSize = findOptimalFontSize(text, constraints.width, constraints.height, initialFontSize, minFontSize, fontFamily);
    if (originalOptimalSize >= minFontSize) {
      const originalDimensions = measureText(text, originalOptimalSize, fontFamily);
      if (originalDimensions.width <= constraints.width && originalDimensions.height <= constraints.height) {
        addLog(`‚úì Fonte reduzida para ${originalOptimalSize}px (texto original)`, 'success');
        return [{ text: text, fontSize: originalOptimalSize }];
      }
    }
  }
  
  if (overflowOption === 'smart' || overflowOption === 'split' || overflowOption === 'both') {
    // ETAPA 3: Dividir em m√∫ltiplos slides com valida√ß√£o rigorosa de altura
    addLog('Iniciando divis√£o em m√∫ltiplos slides...', 'info');
    
    // Primeiro tentar com fonte original
    let parts = splitTextToFitWithHeight(text, constraints.width, constraints.height, initialFontSize, fontFamily);
    
    if (parts.length > 1) {
      addLog(`‚úì Texto dividido em ${parts.length} slides com fonte ${initialFontSize}px`, 'success');
      return parts.map(part => ({ text: part, fontSize: initialFontSize }));
    }
    
    // Se n√£o funcionou, tentar com fonte reduzida
    const reducedSize = Math.max(minFontSize, initialFontSize - 8);
    parts = splitTextToFitWithHeight(text, constraints.width, constraints.height, reducedSize, fontFamily);
    
    if (parts.length > 0) {
      addLog(`‚úì Texto dividido em ${parts.length} slides com fonte ${reducedSize}px`, 'success');
      return parts.map(part => ({ text: part, fontSize: reducedSize }));
    }
  }
  
  // ETAPA 4: √öltimo recurso - divis√£o for√ßada por linhas
  addLog('Aplicando divis√£o for√ßada por limita√ß√£o de altura...', 'warning');
  const forcedParts = splitTextByLines(text, constraints.width, constraints.height, minFontSize, fontFamily);
  
  if (forcedParts.length > 0) {
    addLog(`‚ö†Ô∏è Texto dividido for√ßadamente em ${forcedParts.length} slides`, 'warning');
    return forcedParts.map(part => ({ text: part, fontSize: minFontSize }));
  }
  
  // √öltimo recurso absoluto: retornar o texto original com fonte m√≠nima
  addLog('‚ö†Ô∏è Usando configura√ß√£o de emerg√™ncia (pode ultrapassar limites)', 'error');
  return [{ text: text, fontSize: minFontSize }];
}

// NOVA FUN√á√ÉO: Divis√£o de texto com valida√ß√£o rigorosa de altura
function splitTextToFitWithHeight(text, maxWidth, maxHeight, fontSize, fontFamily = 'Arial') {
  const lines = text.split('\n');
  const parts = [];
  let currentPart = [];
  
  for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
    const line = lines[lineIndex];
    
    // Testar se podemos adicionar esta linha ao slide atual
    const testText = [...currentPart, line].join('\n');
    const testDimensions = measureText(testText, fontSize, fontFamily);
    
    // VALIDA√á√ÉO RIGOROSA: Verificar largura E altura
    if (testDimensions.width <= maxWidth && testDimensions.height <= maxHeight) {
      currentPart.push(line);
    } else {
      // Esta linha fez ultrapassar os limites
      if (currentPart.length > 0) {
        // Salvar o slide atual
        parts.push(currentPart.join('\n'));
        currentPart = [];
      }
      
      // Verificar se a linha sozinha cabe no slide
      const singleLineDimensions = measureText(line, fontSize, fontFamily);
      
      if (singleLineDimensions.width <= maxWidth && singleLineDimensions.height <= maxHeight) {
        // A linha cabe sozinha
        currentPart.push(line);
      } else if (singleLineDimensions.width > maxWidth) {
        // Linha muito larga, precisa quebrar por palavras
        const wordsInLine = splitLineIntoSlides(line, maxWidth, maxHeight, fontSize, fontFamily);
        
        for (let i = 0; i < wordsInLine.length; i++) {
          const wordGroup = wordsInLine[i];
          
          if (currentPart.length === 0) {
            currentPart.push(wordGroup);
          } else {
            // Testar se podemos adicionar ao slide atual
            const testWithWords = [...currentPart, wordGroup].join('\n');
            const testDimensionsWords = measureText(testWithWords, fontSize, fontFamily);
            
            if (testDimensionsWords.width <= maxWidth && testDimensionsWords.height <= maxHeight) {
              currentPart.push(wordGroup);
            } else {
              // N√£o cabe, criar novo slide
              parts.push(currentPart.join('\n'));
              currentPart = [wordGroup];
            }
          }
        }
      } else {
        // Linha cabe na largura mas n√£o na altura (muitas linhas acumuladas)
        // For√ßar cria√ß√£o de novo slide
        currentPart = [line];
      }
    }
  }
  
  // Adicionar √∫ltimo slide se houver conte√∫do
  if (currentPart.length > 0) {
    parts.push(currentPart.join('\n'));
  }
  
  // Valida√ß√£o final: verificar se cada parte realmente cabe
  const validatedParts = [];
  for (let part of parts) {
    const partDimensions = measureText(part, fontSize, fontFamily);
    if (partDimensions.width <= maxWidth && partDimensions.height <= maxHeight) {
      validatedParts.push(part);
    } else {
      // Esta parte ainda n√£o cabe, dividir mais
      addLog(`‚ö†Ô∏è Parte ainda muito grande (${partDimensions.width}x${partDimensions.height}), dividindo mais...`, 'warning');
      const subParts = splitTextByLines(part, maxWidth, maxHeight, fontSize, fontFamily);
      validatedParts.push(...subParts);
    }
  }
  
  return validatedParts.filter(part => part.trim().length > 0);
}

// NOVA FUN√á√ÉO: Dividir linha em grupos de palavras que cabem no slide
function splitLineIntoSlides(line, maxWidth, maxHeight, fontSize, fontFamily = 'Arial') {
  const words = line.split(' ');
  const wordGroups = [];
  let currentGroup = [];
  
  for (let word of words) {
    const testGroup = [...currentGroup, word].join(' ');
    const testDimensions = measureText(testGroup, fontSize, fontFamily);
    
    if (testDimensions.width <= maxWidth && testDimensions.height <= maxHeight) {
      currentGroup.push(word);
    } else {
      if (currentGroup.length > 0) {
        wordGroups.push(currentGroup.join(' '));
        currentGroup = [word];
      } else {
        // Palavra muito longa, for√ßar inclus√£o
        wordGroups.push(word);
      }
    }
  }
  
  if (currentGroup.length > 0) {
    wordGroups.push(currentGroup.join(' '));
  }
  
  return wordGroups;
}

// NOVA FUN√á√ÉO: Divis√£o for√ßada por linhas (√∫ltimo recurso)
function splitTextByLines(text, maxWidth, maxHeight, fontSize, fontFamily = 'Arial') {
  const lines = text.split('\n');
  const parts = [];
  let currentLines = [];
  
  for (let line of lines) {
    // Sempre come√ßar com uma linha no slide
    if (currentLines.length === 0) {
      currentLines.push(line);
      continue;
    }
    
    const testText = [...currentLines, line].join('\n');
    const dimensions = measureText(testText, fontSize, fontFamily);
    
    if (dimensions.height <= maxHeight) {
      currentLines.push(line);
    } else {
      // Altura excedida, criar novo slide
      if (currentLines.length > 0) {
        parts.push(currentLines.join('\n'));
      }
      currentLines = [line];
    }
  }
  
  if (currentLines.length > 0) {
    parts.push(currentLines.join('\n'));
  }
  
  return parts.filter(part => part.trim().length > 0);
}

// Fun√ß√£o para encontrar o maior tamanho de fonte que cabe
function findOptimalFontSize(text, maxWidth, maxHeight, initialSize, minSize, fontFamily = 'Arial') {
  let fontSize = initialSize;
  
  while (fontSize >= minSize) {
    const dimensions = measureText(text, fontSize, fontFamily);
    if (dimensions.width <= maxWidth && dimensions.height <= maxHeight) {
      return fontSize;
    }
    fontSize -= 1; // Reduzir em incrementos menores para melhor precis√£o
  }
  
  return minSize;
}

// Fun√ß√£o de log
function addLog(message, type = 'info') {
  const logDiv = document.getElementById('log');
  const logContent = document.getElementById('logContent');
  
  const logItem = document.createElement('div');
  logItem.className = `log-item log-${type}`;
  logItem.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
  
  logContent.appendChild(logItem);
  logDiv.classList.remove('hidden');
  logContent.scrollTop = logContent.scrollHeight;
}

// Fun√ß√£o principal de gera√ß√£o (MELHORADA)
async function generatePPTX() {
  if(musicSequence.length === 0) return alert("Adicione pelo menos uma m√∫sica √† sequ√™ncia.");

  if (editingIndex !== -1) {
    alert("Finalize a edi√ß√£o da m√∫sica atual antes de gerar o arquivo.");
    return;
  }

  const progressDiv = document.getElementById('progress');
  const progressBar = document.getElementById('progressBar');
  const logContent = document.getElementById('logContent');
  
  logContent.innerHTML = '';
  progressDiv.classList.remove('hidden');
  
  addLog('Iniciando gera√ß√£o do PowerPoint...', 'success');

  const pptx = new PptxGenJS();
  const layout = document.getElementById("layout").value;
  pptx.layout = layout;
  
  const textColor = document.getElementById("textColor").value;
  const bgColor = document.getElementById("bgColor").value;
  const initialFontSize = parseInt(document.getElementById("fontSize").value);
  const minFontSize = parseInt(document.getElementById("minFontSize").value);
  const align = document.getElementById("align").value;
  const caseOpt = document.getElementById("caseOption").value;
  const overflowOption = document.getElementById("overflowOption").value;
  
  const fontFamily = document.getElementById("fontFamily").value;
  const selectedEffects = Array.from(document.getElementById("fontEffects").selectedOptions).map(option => option.value);
  const isBold = selectedEffects.includes('bold');
  const isItalic = selectedEffects.includes('italic');

  const constraints = getSlideConstraints(layout);
  addLog(`Dimens√µes do slide: ${constraints.width}x${constraints.height}px`, 'info');
  addLog(`Estrat√©gia de overflow: ${overflowOption}`, 'info');

  let allSlides = [];
  let totalSlides = 0;
  
  for (let musicIndex = 0; musicIndex < musicSequence.length; musicIndex++) {
    let music = musicSequence[musicIndex];
    
    if(caseOpt === "upper") music = music.toUpperCase();
    if(caseOpt === "lower") music = music.toLowerCase();
    
    let blocks = music.split(/\n\s*\n/).map(b => b.trim().replace(/\n{2,}/g, "\n"));
    
    addLog(`Processando m√∫sica ${musicIndex + 1} com ${blocks.length} estrofe(s)`, 'info');
    
    for (let blockIndex = 0; blockIndex < blocks.length; blockIndex++) {
      let block = blocks[blockIndex];
      if (!block.trim()) continue;
      
      addLog(`--- Processando estrofe ${blockIndex + 1} ---`, 'info');
      
      // Usar a nova fun√ß√£o de processamento inteligente
      const processedSlides = processTextForSlide(
        block, 
        constraints, 
        initialFontSize, 
        minFontSize, 
        overflowOption,
        fontFamily
      );
      
      allSlides.push(...processedSlides);
      totalSlides += processedSlides.length;
    }
    
    // Slide separador (exceto na √∫ltima m√∫sica)
    if (musicIndex < musicSequence.length - 1) {
      allSlides.push({ text: "", fontSize: initialFontSize });
      totalSlides++;
    }
    
    progressBar.style.width = ((musicIndex + 1) / musicSequence.length * 50) + '%';
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  addLog(`Total de ${totalSlides} slides criados`, 'success');
  
  for (let i = 0; i < allSlides.length; i++) {
    const { text, fontSize } = allSlides[i];
    const slide = pptx.addSlide();
    slide.background = { color: bgColor };
    
    slide.addText(text, {
      x: 0.5, 
      y: 0.5, 
      w: "90%", 
      h: "90%",
      fontSize: fontSize,
      fontFace: fontFamily,
      bold: isBold,
      italic: isItalic,
      color: textColor,
      align: align,
      valign: "middle",
      margin: 0.3
    });
    
    progressBar.style.width = (50 + (i / allSlides.length * 50)) + '%';
    await new Promise(resolve => setTimeout(resolve, 50));
  }

  progressBar.style.width = '100%';
  addLog('PowerPoint gerado com sucesso!', 'success');
  
  try {
    await pptx.writeFile({ fileName: "sequencia_musicas.pptx" });
    addLog('Arquivo baixado com sucesso!', 'success');
  } catch (error) {
    addLog('Erro ao baixar arquivo: ' + error.message, 'error');
  }
  
  setTimeout(() => {
    progressDiv.classList.add('hidden');
  }, 3000);
}

// Inicializar a interface
document.addEventListener('DOMContentLoaded', function() {
  renderMusicList();
  addLog('Sistema iniciado - Pronto para uso!', 'success');
});
</script>
</body>
</html>